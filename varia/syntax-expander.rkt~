#lang racket

(define (let->lambda exp)
  (let* ((let-bindings (cadr exp))
         (let-body (cddr exp))
         (let-vars (map car let-bindings))
         (let-vals (map cadr let-bindings)))
    `((lambda ,let-vars ,@let-body) ,@let-vals)))

;;expects no shadowing of previous variables
(define (let->define exp)
  (let ((let-bindings (cadr exp))
        (let-body (cddr exp)))
    `(begin ,@(map (lambda (binding)
                     (let ((var (car binding))
                           (val (cadr binding)))
                       `(define ,var ,val)))
                   let-bindings)
            ,@let-body)))

;(let->lambda '(let ((x 2) (y 3) (z 4)) (+ 1 x y z) x y))
;(let->define '(let ((x 2) (y 3) (z 4)) (+ 1 x y z) x y))

(define (named-let->loop exp)
  (let* ((nl-identifier (cadr exp))
         (nl-bindings (caddr exp))
         (nl-vars (map car nl-bindings))
         (nl-vals (map cadr nl-bindings))
         (nl-body (cdddr exp)))
    `(begin
       (define (,nl-identifier ,@nl-vars)
         ,@nl-body)
       (,nl-identifier ,@nl-vals))))

(named-let->loop '(let test ((n 10) 
                             (acc 1))
                    (if (= n 0)
                        acc
                        (test (- n 1)
                              (* acc n)))))


(define (do->loop exp)
  (let* ((do-bindings (cadr exp))
         (do-vars (map car do-bindings))
         (do-vals (map cadr do-bindings))
         (do-incr (map caddr do-bindings))
         (do-clause (caddr exp))
         (do-pred (car do-clause))
         (do-exit (cdr do-clause))
         (do-body (cdddr exp)))
    `(begin
       (define (loop ,@do-vars)
         (if ,do-pred
             (begin ,@do-exit)
             (begin
               ,@do-body
               (loop ,@do-incr))))
       (loop ,@do-vals))))

;(do->loop '(do ((n 10 (- n 1))
;                (acc 1 (* n acc)))
;             ((= n 0) acc)))

(define (cond->if c)
  (define (loop exp)
    (if (null? exp)
        '()
        (let* ((first (car exp))
               (pred (car first))
               (body (cdr first)))
          (if (eq? pred 'else)
              `(begin ,@body)
              `(if ,pred
                   (begin ,@body)
                   ,(loop (cdr exp)))))))
  (loop (cdr c)))

;(cond->if '(cond ((= x 2) 'one)
;                ((= y 3) 'two)
;                 (else 'else)))

(define (transform program)
  (if (pair? program)
      (let ((opr (car program))
            (opd (cdr program)))
        (cond ((or (eq? opr 'let) (eq? opr 'let*))
               (if (symbol? (car opd))
                   (transform (named-let->loop program))
                   (transform (let->define program))))
              ((eq? opr 'cond)
               (transform (cond->if program)))
              ((eq? opr 'do)
               (transform (do->loop program)))
              (else
               (cons (transform opr)
                     (transform opd)))))
      program))

(transform
 '(begin
    (define (count r i step x y)
      
      (let ((max-count 64)
            (radius^2  16.0))
        
        (let ((cr (+ r (* (inexact x) step)))
              (ci (+ i (* (inexact y) step))))
          
          (let loop ((zr cr)
                     (zi ci)
                     (c 0))
            (if (= c max-count)
                c
                (let ((zr^2 (* zr zr))
                      (zi^2 (* zi zi)))
                  (if (> (+ zr^2 zi^2) radius^2)
                      c
                      (let ((new-zr (+ (- zr^2 zi^2) cr))
                            (new-zi (+ (* 2.0 (* zr zi)) ci)))
                        (loop new-zr new-zi (+ c 1))))))))))
    (define (mbrot matrix r i step n)
      (let loop1 ((y (- n 1)))
        (if (>= y 0)
            (let loop2 ((x (- n 1)))
              (if (>= x 0)
                  (begin
                    (vector-set! (vector-ref matrix x) y (count r i step x y))
                    (loop2 (- x 1)))
                  (loop1 (- y 1)))))))
    
    (define (test n)
      (let ((matrix (make-vector n)))
        (let loop ((i (- n 1)))
          (if (>= i 0)
              (begin
                (vector-set! matrix i (make-vector n))
                (loop (- i 1)))))
        (mbrot matrix -1.0 -0.5 0.005 n)
        (vector-ref (vector-ref matrix 0) 0)))))